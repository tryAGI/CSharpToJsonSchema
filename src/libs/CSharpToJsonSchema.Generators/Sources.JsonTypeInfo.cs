using CSharpToJsonSchema.Generators.Conversion;
using CSharpToJsonSchema.Generators.JsonGen;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using CSharpToJsonSchema.Generators.Models;
using H.Generators.Extensions;

namespace CSharpToJsonSchema.Generators;

internal static partial class Sources
{
    public static string GenerateJsonTypeInfoImplementation(InterfaceData @interface, IncrementalGeneratorInitializationContext context)
    {
        throw new NotImplementedException();
      //  var sk = SymbolGenerator.GenerateParameterBasedClassSymbol(@interface, !@interface.Methods.First())
    }

    public static global::H.Generators.Extensions.FileWithName GenerateJsonTypeInfoImplementation(ClassData classData)
    {

        
        // var ag = new JsonSourceGenerator();
        // ag.Initialize(con);
         throw new NotImplementedException();
        // // We'll generate a partial class in the same namespace.
        // var sb2 = new global::System.Text.StringBuilder();
        // sb2.AppendLine("#if NET6_0_OR_GREATER");
        // sb2.AppendLine("#nullable enable");
        // sb2.AppendLine("// <auto-generated/>");
        // sb2.AppendLine($"namespace {classData.Namespace}");
        // sb2.AppendLine("{");
        // var extensionsClassName = classData.Name.Substring(startIndex: 1) + "Extensions";
        //
        // var fileName = $"{extensionsClassName}JsonTypeInfoExtensions.cs";
        //
        // var members = classData.ClassSymbol.GetMembers().OfType<IMethodSymbol>();
        // foreach (IMethodSymbol member in members)
        // {
        //     var className = $"{member.Name}Args";
        //     var ns = $"{classData.Namespace}";
        //     
        //     
        //     //var classSymbol = ToClassSymbol(member);
        //     var file = CreateJsonTypeInfoSource(className, ns, member.ReturnType);
        //
        //     sb2.AppendLine(file);
        //
        //     //className = $"{member.ReturnType.Name}"
        //     //var file2 = GenerateJsonTypeInfoCalls(classData);
        // }
        //
        // sb2.AppendLine("}");
        // sb2.AppendLine("#endif");
        //
        // return new global::H.Generators.Extensions.FileWithName(fileName, sb2.ToString());
    }

  // private const BindingFlags InstanceMemberBindingFlags = BindingFlags.Instance | BindingFlags.Public;

    public static string CreateJsonTypeInfoSource(
        string className,
        string nameSpace,
        ITypeSymbol classSymbol)
    {
        // Use a dictionary to track visited types and their generated method names.
        var visitedTypes = new Dictionary<ITypeSymbol, string>(SymbolEqualityComparer.Default);

        // A StringBuilder for the entire code snippet.
        var sb = new global::System.Text.StringBuilder();

        // Fully qualified name of the target class.
        string fullyQualifiedClassName = classSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

        // 1. Generate the outer partial class.
        sb.AppendLine($"public partial class {className}");
        sb.AppendLine("{");

        // 2. Generate the private JsonTypeInfo<T> field.
        sb.AppendLine($"    private global::System.Text.Json.Serialization.Metadata.JsonTypeInfo<{fullyQualifiedClassName}>? _{ToCamelCase(className)};");
        sb.AppendLine();

        // 3. Generate the public JsonTypeInfo<T> property.
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Defines the source generated JSON serialization contract metadata for a given type.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    #nullable disable annotations");
        sb.AppendLine($"    public global::System.Text.Json.Serialization.Metadata.JsonTypeInfo<{fullyQualifiedClassName}> {className}JSON");
        sb.AppendLine("    #nullable enable annotations");
        sb.AppendLine("    {");
        sb.AppendLine($"        get => _{ToCamelCase(className)} ??= (global::System.Text.Json.Serialization.Metadata.JsonTypeInfo<{fullyQualifiedClassName}>)global::System.Text.Json.JsonSerializer.Serialize(new {fullyQualifiedClassName}());");
        sb.AppendLine("    }");
        sb.AppendLine();

        // Call the recursive helper function to generate the Create_ and related methods.
        GenerateTypeInfoMethods(sb, classSymbol, visitedTypes);

        sb.AppendLine("}"); // End of class.

        return sb.ToString();
    }

    private static void GenerateTypeInfoMethods(global::System.Text.StringBuilder sb, ITypeSymbol typeSymbol, Dictionary<ITypeSymbol, string> visitedTypes)
    {
        // If we've already visited this type, return.
        if (visitedTypes.ContainsKey(typeSymbol))
        {
            return;
        }

        // Generate a unique method name for this type.
        string methodName = $"Create_{UniqueSafeName(typeSymbol)}";
        visitedTypes[typeSymbol] = methodName; // Mark as visited.

        string fullyQualifiedTypeName = typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        string typeName = typeSymbol.Name;

        // 4. Generate the Create_{Type}() method.
        sb.AppendLine($"    private global::System.Text.Json.Serialization.Metadata.JsonTypeInfo<{fullyQualifiedTypeName}> {methodName}(global::System.Text.Json.JsonSerializerOptions options)");
        sb.AppendLine("    {");
        sb.AppendLine($"        if (!TryGetTypeInfoForRuntimeCustomConverter<{fullyQualifiedTypeName}>(options, out global::System.Text.Json.Serialization.Metadata.JsonTypeInfo<{fullyQualifiedTypeName}> jsonTypeInfo))");
        sb.AppendLine("        {");

        // Constructor Handling
        var constructors = typeSymbol.GetMembers().OfType<IMethodSymbol>().Where(m => m.MethodKind == MethodKind.Constructor);
        var parameterlessConstructor = constructors.FirstOrDefault(c => c.Parameters.Length == 0);
        var parameterizedConstructor = constructors.FirstOrDefault(c => c.Parameters.Length > 0);

        sb.AppendLine($"            var objectInfo = new global::System.Text.Json.Serialization.Metadata.JsonObjectInfoValues<{fullyQualifiedTypeName}>");
        sb.AppendLine("            {");
        sb.AppendLine($"                ObjectCreator = () => new {fullyQualifiedTypeName}(),"); // Default constructor

        // Handle parameterized constructor (if any)
        if (parameterizedConstructor != null)
        {
            var parameterList = string.Join(", ", parameterizedConstructor.Parameters.Select(p => $"args[{p.Ordinal}]"));
            sb.AppendLine($"                ObjectWithParameterizedConstructorCreator = args => new {fullyQualifiedTypeName}({parameterList}),");
        }
        else
        {
            sb.AppendLine("                ObjectWithParameterizedConstructorCreator = null,");
        }

        sb.AppendLine($"                PropertyMetadataInitializer = _ => {typeName}PropInit(options),");
        sb.AppendLine($"                ConstructorParameterMetadataInitializer = {(parameterizedConstructor != null ? $"{typeName}ConstParamInit" : "null")},");

        // Get constructor parameter types (if any)
        var constructorParameterTypes = parameterizedConstructor != null
            ? $"new{{ {string.Join(", ", parameterizedConstructor.Parameters.Select(p => $"typeof({p.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)})"))} }}"
            : "global::System.Array.Empty<global::System.Type>()";

        sb.AppendLine($"                ConstructorAttributeProviderFactory = static () => typeof({fullyQualifiedTypeName}).GetConstructor(InstanceMemberBindingFlags, binder: null, {constructorParameterTypes}, modifiers: null),");
        sb.AppendLine($"                SerializeHandler = {typeName}SerializeHandler,");
        sb.AppendLine("            };");
        sb.AppendLine();
        sb.AppendLine($"            jsonTypeInfo = global::System.Text.Json.Serialization.Metadata.JsonMetadataServices.CreateObjectInfo<{fullyQualifiedTypeName}>(options, objectInfo);");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        jsonTypeInfo.OriginatingResolver = this;");
        sb.AppendLine("        return jsonTypeInfo;");
        sb.AppendLine("    }");
        sb.AppendLine();

        // 5. Generate the {Type}PropInit() method.
        sb.AppendLine($"    private static global::System.Text.Json.Serialization.Metadata.JsonPropertyInfo{typeName}PropInit(global::System.Text.Json.JsonSerializerOptions options)");
        sb.AppendLine("    {");

        // Get all public instance properties.
        var properties = typeSymbol.GetMembers()
            .OfType<IPropertySymbol>()
            .Where(p => p.DeclaredAccessibility == Accessibility.Public && !p.IsStatic && p.GetMethod != null && p.SetMethod != null);

        sb.AppendLine($"        var properties = new global::System.Text.Json.Serialization.Metadata.JsonPropertyInfo[{properties.Count()}];");
        sb.AppendLine();

        int index = 0;
        foreach (var property in properties)
        {
            string fullyQualifiedPropertyType = property.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

            // Check for nested types and generate methods if necessary.
            if (!IsSimpleType(property.Type))
            {
                GenerateTypeInfoMethods(sb, property.Type, visitedTypes);
            }

            sb.AppendLine($"        var info{index} = new global::System.Text.Json.Serialization.Metadata.JsonPropertyInfoValues<{fullyQualifiedPropertyType}>");
            sb.AppendLine("        {");
            sb.AppendLine("            IsProperty = true,");
            sb.AppendLine("            IsPublic = true,");
            sb.AppendLine("            IsVirtual = false,"); // Adjust as needed.
            sb.AppendLine($"            DeclaringType = typeof({fullyQualifiedTypeName}),");
            sb.AppendLine("            Converter = null,");
            sb.AppendLine($"            Getter = static obj => (({fullyQualifiedTypeName})obj).{property.Name},");
            sb.AppendLine($"            Setter = static (obj, value) => (({fullyQualifiedTypeName})obj).{property.Name} = value!,");
            sb.AppendLine("            IgnoreCondition = null,");
            sb.AppendLine("            HasJsonInclude = false,"); // Adjust as needed
            sb.AppendLine("            IsExtensionData = false,"); // Adjust as needed.
            sb.AppendLine("            NumberHandling = null,"); // Adjust as needed.
            sb.AppendLine($"            PropertyName = \"{property.Name}\",");
            sb.AppendLine($"            JsonPropertyName = \"{ToSnakeCase(property.Name)}\","); // example: using snake_case
            sb.AppendLine($"            AttributeProviderFactory = static () => typeof({fullyQualifiedTypeName}).GetProperty(\"{property.Name}\", InstanceMemberBindingFlags, null, typeof({fullyQualifiedPropertyType}), global::System.Array.Empty<global::System.Type>(), null),");
            sb.AppendLine("        };");
            sb.AppendLine();
            sb.AppendLine($"        properties[{index}] = global::System.Text.Json.Serialization.Metadata.JsonMetadataServices.CreatePropertyInfo<{fullyQualifiedPropertyType}>(options, info{index});");

            // Handle nullability.
            if (property.Type.NullableAnnotation == NullableAnnotation.Annotated)
            {
                // If the *property* is nullable, then IsGetNullable and IsSetNullable should both be true.
                sb.AppendLine($"        properties[{index}].IsGetNullable = true;");
                sb.AppendLine($"        properties[{index}].IsSetNullable = true;");
            }
            else
            {
                sb.AppendLine($"        properties[{index}].IsGetNullable = false;");
                sb.AppendLine($"        properties[{index}].IsSetNullable = false;");
            }

            index++;
        }

        sb.AppendLine();
        sb.AppendLine("        return properties;");
        sb.AppendLine("    }");
        sb.AppendLine();

        // 6. Generate the {Type}SerializeHandler() method.
        sb.AppendLine($"    private void {typeName}SerializeHandler(global::System.Text.Json.Utf8JsonWriter writer, {fullyQualifiedTypeName}? value)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (value is null)");
        sb.AppendLine("        {");
        sb.AppendLine("            writer.WriteNullValue();");
        sb.AppendLine("            return;");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        writer.WriteStartObject();");
        sb.AppendLine();

        foreach (var property in properties)
        {
            sb.AppendLine($"        writer.WritePropertyName(\"{ToSnakeCase(property.Name)}\");"); // example using snake case

            // If the property is a simple type, serialize directly.
            if (IsSimpleType(property.Type))
            {
                sb.AppendLine($"        global::System.Text.Json.JsonSerializer.Serialize(writer, ((global::{fullyQualifiedTypeName})value).{property.Name}, options);");
            }
            else
            {
                // Otherwise, call the appropriate SerializeHandler for the nested type.
                string nestedTypeName = property.Type.Name;
                sb.AppendLine($"        {nestedTypeName}SerializeHandler(writer, ((global::{fullyQualifiedTypeName})value).{property.Name});");
            }
        }

        sb.AppendLine();
        sb.AppendLine("        writer.WriteEndObject();");
        sb.AppendLine("    }");
        sb.AppendLine();

        // 7. Generate the {Type}ConstParamInit() method (if needed)
        if (parameterizedConstructor != null)
        {
            sb.AppendLine($"    private static global::System.Text.Json.Serialization.Metadata.JsonParameterInfo{typeName}ConstParamInit(global::System.Text.Json.JsonSerializerOptions options)");
            sb.AppendLine("    {");

            var parameters = new List<string>();
            for (int i = 0; i < parameterizedConstructor.Parameters.Length; i++)
            {
                var parameter = parameterizedConstructor.Parameters[i];
                string fullyQualifiedParameterType = parameter.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

                parameters.Add($"        new global::System.Text.Json.Serialization.Metadata.JsonParameterInfoValues<{fullyQualifiedParameterType}>");
                parameters.Add("        {");
                parameters.Add($"            Name = \"{parameter.Name}\",");
                parameters.Add($"            ParameterType = typeof({fullyQualifiedParameterType}),");
                parameters.Add($"            Position = {i},");
                parameters.Add($"            HasDefaultValue = {parameter.HasExplicitDefaultValue.ToString().ToLower()},");
                if (parameter.HasExplicitDefaultValue)
                {
                    parameters.Add($"            DefaultValue = {parameter.ExplicitDefaultValue},");
                }
                parameters.Add($"            AttributeProviderFactory = static () => typeof({fullyQualifiedParameterType}).GetConstructor(InstanceMemberBindingFlags, binder: null, new{{ typeof({fullyQualifiedParameterType}) }}, modifiers: null),");
                parameters.Add($"            IsParameterRequired = {!parameter.NullableAnnotation.Equals(NullableAnnotation.Annotated)},");
                parameters.Add("        },");
            }
            sb.AppendLine($"        var parameters = new global::System.Text.Json.Serialization.Metadata.JsonParameterInfo");
            sb.AppendLine("        {");
            foreach (var item in parameters)
            {
                sb.AppendLine(item);
            }
            sb.AppendLine("        };");
            sb.AppendLine("        return parameters;");
            sb.AppendLine("    }");
            sb.AppendLine();
        }
    }
    private static bool IsSimpleType(ITypeSymbol type)
    {
        // Consider basic types and strings as "simple".
        return type.SpecialType != SpecialType.None || type.TypeKind == TypeKind.Enum;
    }

    private static string UniqueSafeName(ITypeSymbol symbol)
    {
        // Example approach
        return string.Join("_", symbol.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat)
            .Split(new[] { '.', '+', '<', '>', '[', ']' }, System.StringSplitOptions.RemoveEmptyEntries));
    }

    public static string ToSnakeCase(string str)
    {
        return string.Concat(str.Select((x, i) => i > 0 && char.IsUpper(x) ? "_" + x.ToString() : x.ToString()))
            .ToLower();
    }

    public static string ToCamelCase(string str)
    {
        if (!string.IsNullOrEmpty(str) && str.Length > 1)
        {
            return char.ToLowerInvariant(str[0]) + str.Substring(1);
        }

        return str.ToLowerInvariant();
    }
}

//     public static global::System.String CreateJsonTypeInfoExtension(
//     string className,
//     string extensionClassName,
//     string nameSpace,
//     IMethodSymbol methodInfo)
// {
//     // Set used for all discovered types (to avoid repeated generation or recursion loops)
//     var visitedTypes =
//         new global::System.Collections.Generic.Dictionary<ITypeSymbol, string>(SymbolEqualityComparer.Default);
//
//     // A StringBuilder for the entire code snippet
//     var sb = new global::System.Text.StringBuilder();
//
//     // 1) Generate the outer partial class
//     string fullTypeName = $"global::{nameSpace}.{extensionClassName}.{className}";
//     string topLevelMethodName = $"CreateJsonTypeInfo_TopLevel";
//
//     sb.AppendLine($"    public static partial class {extensionClassName}{className}JsonTypeInfoExtensions");
//     sb.AppendLine("    {");
//
//     // 2) Generate the “user accessible” method that returns the JsonTypeInfo for the top-level type
//     sb.AppendLine("        /// <summary>");
//     sb.AppendLine($"        /// Returns a JsonTypeInfo for {className}, including nested types if present.");
//     sb.AppendLine(
//         "        /// Enum properties will use a typed JsonStringEnumConverter<T> for string-based (de)serialization.");
//     sb.AppendLine("        /// </summary>");
//     sb.AppendLine(
//         $"        public static global::System.Text.Json.Serialization.Metadata.JsonTypeInfo<{fullTypeName}> CreateJsonTypeInfo()");
//     sb.AppendLine("        {");
//     sb.AppendLine($"            // Defer to our generated method for the top-level type");
//     sb.AppendLine(
//         $"            return {topLevelMethodName}(new global::System.Text.Json.JsonSerializerOptions());");
//     sb.AppendLine("        }");
//
//     sb.AppendLine();
//
//     // 3) Generate the actual “top-level” method that returns a JsonTypeInfo<T>.
//     sb.AppendLine(
//         $"        private static global::System.Text.Json.Serialization.Metadata.JsonTypeInfo<{fullTypeName}> {topLevelMethodName}(global::System.Text.Json.JsonSerializerOptions options)");
//     sb.AppendLine("        {");
//     sb.AppendLine("            // Prepare a list of all discovered properties");
//     sb.AppendLine(
//         "            var propertyInfos = new global::System.Collections.Generic.List<global::System.Text.Json.Serialization.Metadata.JsonPropertyInfo>();");
//     sb.AppendLine();
//
//     // Generate code for the parameters as if they are the “properties” of the top-level type
//     foreach (var prop in methodInfo.Parameters)
//     {
//         // Skip certain types (e.g., CancellationToken)
//         if (prop.Type.Name == "CancellationToken")
//             continue;
//
//         // Add code for a single property
//         AddPropertyGenerationCode(sb, prop.Type, prop.Name.ToPropertyName(), fullTypeName, "options");
//
//         // Also ensure we generate code for nested types
//         GenerateNestedTypeCode(sb, prop.Type, visitedTypes);
//     }
//
//     // Now create an “object info values” for the top-level
//     sb.AppendLine(
//         $"            var objectInfoValues = new global::System.Text.Json.Serialization.Metadata.JsonObjectInfoValues<{fullTypeName}>");
//     sb.AppendLine("            {");
//     sb.AppendLine($"                ObjectCreator = static () => new {fullTypeName}(),");
//     sb.AppendLine("                PropertyMetadataInitializer = _ => propertyInfos.ToArray()");
//     sb.AppendLine("            };");
//     sb.AppendLine();
//
//     sb.AppendLine(
//         $"            var typeInfo = global::System.Text.Json.Serialization.Metadata.JsonMetadataServices.CreateObjectInfo<{fullTypeName}>(");
//     sb.AppendLine("                options,");
//     sb.AppendLine("                objectInfoValues");
//     sb.AppendLine("            );");
//     sb.AppendLine();
//     sb.AppendLine("            return typeInfo;");
//     sb.AppendLine("        }");
//     sb.AppendLine();
//
//     //
//     // 4) Add a custom type resolver class and a helper method that sets it on a new JsonSerializerOptions.
//     //
//     sb.AppendLine("        /// <summary>");
//     sb.AppendLine("        /// A custom resolver that returns the generated JsonTypeInfo for the top-level type.");
//     sb.AppendLine("        /// In a more advanced scenario, you could expand or chain with the default resolver.");
//     sb.AppendLine("        /// </summary>");
//     sb.AppendLine($"        private sealed class {className}JsonTypeInfoResolver : global::System.Text.Json.Serialization.Metadata.IJsonTypeInfoResolver");
//     sb.AppendLine("        {");
//     sb.AppendLine("            public global::System.Text.Json.Serialization.Metadata.JsonTypeInfo? GetTypeInfo(");
//     sb.AppendLine("                global::System.Type type, global::System.Text.Json.JsonSerializerOptions options)");
//     sb.AppendLine("            {");
//     sb.AppendLine($"                if (type == typeof({fullTypeName}))");
//     sb.AppendLine("                {");
//     sb.AppendLine($"                    return {topLevelMethodName}(options);");
//     sb.AppendLine("                }");
//     sb.AppendLine();
//     sb.AppendLine("                // As-is, returns null for other types. You can override further as needed.");
//     sb.AppendLine("                return null;");
//     sb.AppendLine("            }");
//     sb.AppendLine("        }");
//     sb.AppendLine();
//
//     sb.AppendLine("        /// <summary>");
//     sb.AppendLine("        /// Returns a new JsonSerializerOptions instance using our custom TypeInfo resolver.");
//     sb.AppendLine("        /// </summary>");
//     sb.AppendLine("        public static global::System.Text.Json.JsonSerializerOptions CreateJsonSerializerOptions()");
//     sb.AppendLine("        {");
//     sb.AppendLine("            var options = new global::System.Text.Json.JsonSerializerOptions();");
//     sb.AppendLine($"            options.TypeInfoResolver = new {className}JsonTypeInfoResolver();");
//     sb.AppendLine("            return options;");
//     sb.AppendLine("        }");
//
//     sb.AppendLine("    }"); // End of outer partial class
//
//     // Return the entire generated code
//     return sb.ToString();
//
//     //--------------------------------------------------------------------------
//     // LOCAL HELPER METHODS
//     //--------------------------------------------------------------------------
//
//     // 1) Add generation code for a single “property,” including potential enum converters.
//     void AddPropertyGenerationCode(
//         global::System.Text.StringBuilder builder,
//         ITypeSymbol propType,
//         string propName,
//         string containerFullTypeName,
//         string optionsVarName)
//     {
//         // Convert type to fully qualified name
//         string fullyQualifiedPropType = propType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
//
//         builder.AppendLine("            {");
//         builder.AppendLine("                // If this type is an enum, create a typed JsonStringEnumConverter<>");
//         builder.AppendLine("                global::System.Text.Json.Serialization.JsonConverter? propConverter = null;");
//         builder.AppendLine($"                if (typeof({fullyQualifiedPropType}).IsEnum)");
//         builder.AppendLine("                {");
//         builder.AppendLine("                    var factory = (global::System.Text.Json.Serialization.JsonConverterFactory?)");
//         builder.AppendLine("                        global::System.Activator.CreateInstance(");
//         builder.AppendLine("                            typeof(global::System.Text.Json.Serialization.JsonStringEnumConverter<>).MakeGenericType(");
//         builder.AppendLine($"                                typeof({fullyQualifiedPropType})");
//         builder.AppendLine("                            )");
//         builder.AppendLine("                        );");
//         builder.AppendLine($"                        propConverter = factory?.CreateConverter(typeof({fullyQualifiedPropType}), options);");
//
//         builder.AppendLine("                }");
//         builder.AppendLine();
//
//         builder.AppendLine(
//             $"                var propertyValues = new global::System.Text.Json.Serialization.Metadata.JsonPropertyInfoValues<{fullyQualifiedPropType}>()");
//         builder.AppendLine("                {");
//         builder.AppendLine($"                    PropertyName = \"{propName}\",");
//         builder.AppendLine($"                    DeclaringType = typeof({containerFullTypeName}),");
//         builder.AppendLine(
//             $"                    Getter = static (obj) => (({containerFullTypeName})obj).{propName},");
//         builder.AppendLine(
//             $"                    Setter = static (obj, val) => (({containerFullTypeName})obj).{propName} = val,");
//         builder.AppendLine("                    Converter = propConverter != null");
//         builder.AppendLine(
//             $"                        ? (global::System.Text.Json.Serialization.JsonConverter<{fullyQualifiedPropType}>)propConverter");
//         builder.AppendLine("                        : null");
//         builder.AppendLine("                };");
//         builder.AppendLine();
//
//         builder.AppendLine(
//             $"                var propertyInfo = global::System.Text.Json.Serialization.Metadata.JsonMetadataServices.CreatePropertyInfo<{fullyQualifiedPropType}>(");
//         builder.AppendLine($"                    {optionsVarName},");
//         builder.AppendLine("                    propertyValues");
//         builder.AppendLine("                );");
//         builder.AppendLine();
//
//         builder.AppendLine("                propertyInfos.Add(propertyInfo);");
//         builder.AppendLine("            }");
//         builder.AppendLine();
//     }
//
//     // 2) Attempt to generate code for a nested type (class/struct). If not visited, create a new
//     //    “CreateJsonTypeInfo_TypeName” method. That method can in turn discover further nested types.
//     void GenerateNestedTypeCode(
//         global::System.Text.StringBuilder builder,
//         ITypeSymbol typeSymbol,
//         global::System.Collections.Generic.Dictionary<ITypeSymbol, string> visited)
//     {
//         // If it’s already visited, do nothing
//         if (visited.ContainsKey(typeSymbol))
//             return;
//
//         // If we consider this type “simple” or “skipped,” do nothing further
//         if (IsSimpleOrSkipType(typeSymbol))
//             return;
//
//         // Mark this type as visited
//         var uniqueMethodName = $"CreateJsonTypeInfo_{UniqueSafeName(typeSymbol)}";
//         visited[typeSymbol] = uniqueMethodName;
//
//         // Write the method for this nested type
//         builder.AppendLine($"    // Nested type discovered: {typeSymbol.Name}");
//         builder.AppendLine(
//             $"    // Generating a method for {typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}");
//         builder.AppendLine(
//             $"    private static global::System.Text.Json.Serialization.Metadata.JsonTypeInfo<{typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}> {uniqueMethodName}(global::System.Text.Json.JsonSerializerOptions options)");
//         builder.AppendLine("    {");
//         builder.AppendLine(
//             "        var propertyInfos = new global::System.Collections.Generic.List<global::System.Text.Json.Serialization.Metadata.JsonPropertyInfo>();");
//         builder.AppendLine();
//
//         // For each public instance property with a getter+setter, generate code
//         if (typeSymbol is INamedTypeSymbol nts)
//         {
//             foreach (var member in nts.GetMembers().OfType<IPropertySymbol>())
//             {
//                 if (!IsEligibleProperty(member))
//                     continue;
//
//                 AddPropertyGenerationCode(
//                     builder,
//                     member.Type,
//                     member.Name.ToPropertyName(),
//                     nts.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
//                     "options"
//                 );
//
//                 // Recursively handle that property’s type, if also complex
//                 GenerateNestedTypeCode(builder, member.Type, visited);
//             }
//         }
//
//         // Now define how to create an instance of this nested type
//         string fullyQualified = typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
//         builder.AppendLine(
//             $"        var objectInfoValues = new global::System.Text.Json.Serialization.Metadata.JsonObjectInfoValues<{fullyQualified}>");
//         builder.AppendLine("        {");
//         builder.AppendLine($"            ObjectCreator = static () => new {fullyQualified}(),");
//         builder.AppendLine("            PropertyMetadataInitializer = static _ => propertyInfos.ToArray()");
//         builder.AppendLine("        };");
//         builder.AppendLine();
//
//         builder.AppendLine(
//             $"        var typeInfo = global::System.Text.Json.Serialization.Metadata.JsonMetadataServices.CreateObjectInfo<{fullyQualified}>(");
//         builder.AppendLine("            options,");
//         builder.AppendLine("            objectInfoValues");
//         builder.AppendLine("        );");
//         builder.AppendLine();
//         builder.AppendLine("        return typeInfo;");
//         builder.AppendLine("    }");
//         builder.AppendLine();
//     }
//
//     // Decide if a type should be considered “simple” or “skipped.”
//     bool IsSimpleOrSkipType(ITypeSymbol typeSymbol)
//     {
//         if (typeSymbol.TypeKind == TypeKind.Enum) return true;
//         if (typeSymbol.SpecialType == SpecialType.System_String) return true;
//         if (typeSymbol.IsValueType) return true;
//         if (typeSymbol is IArrayTypeSymbol) return true;
//
//         // Also skip any type in System.* as an example
//         var ns = typeSymbol.ContainingNamespace?.ToDisplayString();
//         if (ns != null && ns.StartsWith("System", System.StringComparison.Ordinal))
//             return true;
//
//         return false;
//     }
//
//     // Decide if a property is public, instance, with both getter and setter
//     bool IsEligibleProperty(IPropertySymbol prop)
//     {
//         if (prop.DeclaredAccessibility != Accessibility.Public) return false;
//         if (prop.IsStatic) return false;
//         if (prop.GetMethod is null || prop.SetMethod is null) return false;
//         return true;
//     }
//
//     // Generate a unique but stable method name for a type
//     string UniqueSafeName(ITypeSymbol symbol)
//     {
//         // Example approach
//         return string.Join("_", symbol.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat)
//             .Split(new[] { '.', '+' }, System.StringSplitOptions.RemoveEmptyEntries));
//     }
//}

// public static global::System.String CreateJsonTypeInfoExtension(
//     string className,
//     string extensionClassName,
//     string nameSpace,
//     IMethodSymbol methodInfo)
// {
//     // Set used for all discovered types (to avoid repeated generation or recursion loops)
//     var visitedTypes =
//         new global::System.Collections.Generic.Dictionary<ITypeSymbol, string>(SymbolEqualityComparer.Default);
//
//     // A StringBuilder for the entire code snippet
//     var sb = new global::System.Text.StringBuilder();
//
//     // 1) Generate the outer partial class
//     string fullTypeName = $"global::{nameSpace}.{extensionClassName}.{className}";
//     // We'll store the top-level method name for the user’s “entry point.”
//     // E.g.: CreateJsonTypeInfo_TopLevel
//     string topLevelMethodName = $"CreateJsonTypeInfo_TopLevel";
//
//     sb.AppendLine($"    public static partial class {extensionClassName}{className}JsonTypeInfoExtensions");
//     sb.AppendLine("    {");
//
//     // 2) Generate the method used to retrieve the JsonTypeInfo for the top-level type.
//     //    This calls a dedicated “internal” method that is generated for that type.
//     sb.AppendLine("        /// <summary>");
//     sb.AppendLine($"        /// Returns a JsonTypeInfo for {className}, including nested types if present.");
//     sb.AppendLine(
//         "        /// Enum properties will use a typed JsonStringEnumConverter<T> for string-based (de)serialization.");
//     sb.AppendLine("        /// </summary>");
//     sb.AppendLine(
//         $"        public static global::System.Text.Json.Serialization.Metadata.JsonTypeInfo<{fullTypeName}> CreateJsonTypeInfo()");
//     sb.AppendLine("        {");
//     sb.AppendLine($"            // Defer to our generated method for the top-level type");
//     sb.AppendLine(
//         $"            return {topLevelMethodName}(new global::System.Text.Json.JsonSerializerOptions());");
//     sb.AppendLine("        }");
//
//     sb.AppendLine();
//
//     // 3) Now generate the actual “top-level” method. It also triggers generation of all discovered nested types.
//     sb.AppendLine(
//         $"        private static global::System.Text.Json.Serialization.Metadata.JsonTypeInfo<{fullTypeName}> {topLevelMethodName}(global::System.Text.Json.JsonSerializerOptions options)");
//     sb.AppendLine("        {");
//     sb.AppendLine("            // Prepare a list of all discovered properties");
//     sb.AppendLine(
//         "            var propertyInfos = new global::System.Collections.Generic.List<global::System.Text.Json.Serialization.Metadata.JsonPropertyInfo>();");
//     sb.AppendLine();
//
//     // Generate code for the parameters as if they are the “properties” of the top-level type
//     foreach (var prop in methodInfo.Parameters)
//     {
//         // Skip certain types (e.g. CancellationToken)
//         if (prop.Type.Name == "CancellationToken")
//             continue;
//
//         // Add code for a single property
//         AddPropertyGenerationCode(sb, prop.Type, prop.Name.ToPropertyName(), fullTypeName, "options");
//
//         // Also ensure we generate metadata methods for nested types
//         GenerateNestedTypeCode(sb, prop.Type, visitedTypes);
//     }
//
//     // Now create this “object info values” for the top-level
//     sb.AppendLine(
//         $"            var objectInfoValues = new global::System.Text.Json.Serialization.Metadata.JsonObjectInfoValues<{fullTypeName}>");
//     sb.AppendLine("            {");
//     sb.AppendLine($"                ObjectCreator = static () => new {fullTypeName}(),");
//     sb.AppendLine("                PropertyMetadataInitializer = _ => propertyInfos.ToArray()");
//     sb.AppendLine("            };");
//     sb.AppendLine();
//
//     sb.AppendLine(
//         $"            var typeInfo = global::System.Text.Json.Serialization.Metadata.JsonMetadataServices.CreateObjectInfo<{fullTypeName}>(");
//     sb.AppendLine("                options,");
//     sb.AppendLine("                objectInfoValues");
//     sb.AppendLine("            );");
//     sb.AppendLine();
//     sb.AppendLine("            return typeInfo;");
//     sb.AppendLine("        }");
//
//     sb.AppendLine("    }"); // End of outer partial class
//
//     // Return the entire generated code
//     return sb.ToString();
//
//     //--------------------------------------------------------------------------
//     // LOCAL HELPER METHODS
//     //--------------------------------------------------------------------------
//
//     // 1) Add generation code for a single “property,” including potential enum converters.
//     void AddPropertyGenerationCode(
//         global::System.Text.StringBuilder builder,
//         ITypeSymbol propType,
//         string propName,
//         string containerFullTypeName,
//         string optionsVarName)
//     {
//         // Convert type to fully qualified name
//         string fullyQualifiedPropType = propType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
//
//         builder.AppendLine("            {");
//         builder.AppendLine("                // If this type is an enum, create a typed JsonStringEnumConverter<>");
//         builder.AppendLine(
//             "                global::System.Text.Json.Serialization.JsonConverter? propConverter = null;");
//         builder.AppendLine($"                if (typeof({fullyQualifiedPropType}).IsEnum)");
//         builder.AppendLine("                {");
//         builder.AppendLine(
//             "                    propConverter = (global::System.Text.Json.Serialization.JsonConverter?)");
//         builder.AppendLine("                        global::System.Activator.CreateInstance(");
//         builder.AppendLine(
//             "                            typeof(global::System.Text.Json.Serialization.JsonStringEnumConverter<>).MakeGenericType(");
//         builder.AppendLine($"                                typeof({fullyQualifiedPropType})");
//         builder.AppendLine("                            )");
//         builder.AppendLine("                        );");
//         builder.AppendLine("                }");
//         builder.AppendLine();
//
//         builder.AppendLine(
//             $"                var propertyValues = new global::System.Text.Json.Serialization.Metadata.JsonPropertyInfoValues<{fullyQualifiedPropType}>()");
//         builder.AppendLine("                {");
//         builder.AppendLine($"                    PropertyName = \"{propName}\",");
//         builder.AppendLine(
//             $"                    Getter = static (obj) => (({containerFullTypeName})obj).{propName},");
//         builder.AppendLine(
//             $"                    Setter = static (obj, val) => (({containerFullTypeName})obj).{propName} = val,");
//         builder.AppendLine("                    Converter = propConverter != null");
//         builder.AppendLine(
//             $"                        ? (global::System.Text.Json.Serialization.JsonConverter<{fullyQualifiedPropType}>)propConverter");
//         builder.AppendLine("                        : null");
//         builder.AppendLine("                };");
//         builder.AppendLine();
//
//         builder.AppendLine(
//             $"                var propertyInfo = global::System.Text.Json.Serialization.Metadata.JsonMetadataServices.CreatePropertyInfo<{fullyQualifiedPropType}>(");
//         builder.AppendLine($"                    {optionsVarName},");
//         builder.AppendLine("                    propertyValues");
//         builder.AppendLine("                );");
//         builder.AppendLine();
//
//         builder.AppendLine("                propertyInfos.Add(propertyInfo);");
//         builder.AppendLine("            }");
//         builder.AppendLine();
//     }
//
//     // 2) Attempt to generate code for a nested type (class/struct). If not visited, create a new
//     //    “CreateJsonTypeInfo_TypeName” method. That method can in turn discover further nested types.
//     void GenerateNestedTypeCode(
//         global::System.Text.StringBuilder builder,
//         ITypeSymbol typeSymbol,
//         global::System.Collections.Generic.Dictionary<ITypeSymbol, string> visited)
//     {
//         // If it’s already visited, do nothing
//         if (visited.ContainsKey(typeSymbol))
//             return;
//
//         // If we consider this type “simple,” skip
//         // (strings, primitives, enums, arrays, or system generics, etc.)
//         // Expand or refine as needed in a real scenario.
//         if (IsSimpleOrSkipType(typeSymbol))
//             return;
//
//         // Mark this type as visited
//         var uniqueMethodName = $"CreateJsonTypeInfo_{UniqueSafeName(typeSymbol)}";
//         visited[typeSymbol] = uniqueMethodName;
//
//         // Write the method
//         builder.AppendLine($"    // Nested type discovered: {typeSymbol.Name}");
//         builder.AppendLine(
//             $"    // Generating a method for {typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}");
//         builder.AppendLine(
//             $"    private static global::System.Text.Json.Serialization.Metadata.JsonTypeInfo<{typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}> {uniqueMethodName}(global::System.Text.Json.JsonSerializerOptions options)");
//         builder.AppendLine("    {");
//         builder.AppendLine(
//             "        var propertyInfos = new global::System.Collections.Generic.List<global::System.Text.Json.Serialization.Metadata.JsonPropertyInfo>();");
//         builder.AppendLine();
//
//         // For each public instance property with getter+setter, do the same
//         if (typeSymbol is INamedTypeSymbol nts)
//         {
//             foreach (var member in nts.GetMembers().OfType<IPropertySymbol>())
//             {
//                 if (!IsEligibleProperty(member))
//                     continue;
//
//                 // Generate the property info snippet
//                 AddPropertyGenerationCode(
//                     builder,
//                     member.Type,
//                     member.Name.ToPropertyName(),
//                     nts.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
//                     "options"
//                 );
//
//                 // Recursively handle that property’s type, if it’s also complex
//                 GenerateNestedTypeCode(builder, member.Type, visited);
//             }
//         }
//
//         // Now define how to create an instance of this nested type
//         string fullyQualified = typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
//         builder.AppendLine(
//             $"        var objectInfoValues = new global::System.Text.Json.Serialization.Metadata.JsonObjectInfoValues<{fullyQualified}>");
//         builder.AppendLine("        {");
//         builder.AppendLine($"            ObjectCreator = static () => new {fullyQualified}(),");
//         builder.AppendLine("            PropertyMetadataInitializer = static _ => propertyInfos.ToArray()");
//         builder.AppendLine("        };");
//         builder.AppendLine();
//
//         builder.AppendLine(
//             $"        var typeInfo = global::System.Text.Json.Serialization.Metadata.JsonMetadataServices.CreateObjectInfo<{fullyQualified}>(");
//         builder.AppendLine("            options,");
//         builder.AppendLine("            objectInfoValues");
//         builder.AppendLine("        );");
//         builder.AppendLine();
//         builder.AppendLine("        return typeInfo;");
//         builder.AppendLine("    }");
//         builder.AppendLine();
//     }
//
//     // Decide if a type should be considered “simple” or “skipped.”
//     bool IsSimpleOrSkipType(ITypeSymbol typeSymbol)
//     {
//         // Skip enums — though they can have a converter, we handle them if they’re direct properties.
//         // But if we’re detecting “nested type” of an enum, we skip here.
//         if (typeSymbol.TypeKind == TypeKind.Enum) return true;
//
//         // Skip strings, primitives, arrays, etc.
//         if (typeSymbol.SpecialType == SpecialType.System_String) return true;
//         if (typeSymbol.IsValueType) return true;
//         if (typeSymbol is IArrayTypeSymbol) return true;
//
//         // Also skip any type in System.* as an example
//         var ns = typeSymbol.ContainingNamespace?.ToDisplayString();
//         if (ns != null && ns.StartsWith("System", System.StringComparison.Ordinal))
//             return true;
//
//         return false;
//     }
//
//     // Decide if a property is public, instance, with both getter/setter
//     bool IsEligibleProperty(IPropertySymbol prop)
//     {
//         if (prop.DeclaredAccessibility != Accessibility.Public) return false;
//         if (prop.IsStatic) return false;
//         if (prop.GetMethod is null || prop.SetMethod is null) return false;
//         return true;
//     }
//
//     // Generate a unique but stable method name for a type
//     string UniqueSafeName(ITypeSymbol symbol)
//     {
//         // For instance, you can use the “metadata name” plus containing namespace
//         // plus an incrementing ID if collisions occur. Below is a simple approach:
//         return string.Join("_", symbol.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat)
//             .Split(new[] { '.', '+' }, System.StringSplitOptions.RemoveEmptyEntries));
//     }
// }

//  public static global::System.String CreateJsonTypeInfoExtension(
//     string className,
//     string extensionClassName,
//     string nameSpace,
//     IMethodSymbol methodInfo)
// {
//     var sb = new global::System.Text.StringBuilder();
//     var ns = nameSpace;
//
//     sb.AppendLine($"    public static partial class {extensionClassName}{className}JsonTypeInfoExtensions");
//     sb.AppendLine("    {");
//     sb.AppendLine("        /// <summary>");
//     sb.AppendLine($"        /// Returns a JsonTypeInfo for {className}, including nested types if present.");
//     sb.AppendLine("        /// Enum properties will use a typed JsonStringEnumConverter<T> for string-based (de)serialization.");
//     sb.AppendLine("        /// </summary>");
//     sb.AppendLine(
//         $"        public static global::System.Text.Json.Serialization.Metadata.JsonTypeInfo<global::{ns}.{extensionClassName}.{className}> CreateJsonTypeInfo()");
//     sb.AppendLine("        {");
//     sb.AppendLine("            // Collect property info objects");
//     sb.AppendLine("            var propertyInfos = new global::System.Collections.Generic.List<global::System.Text.Json.Serialization.Metadata.JsonPropertyInfo>();");
//     sb.AppendLine();
//
//     // Generate metadata for each parameter
//     foreach (var prop in methodInfo.Parameters)
//     {
//         if(prop.Type.Name == "CancellationToken")
//             continue;
//         var propTypeName = prop.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
//         var propName = prop.Name.ToPropertyName();
//         var overriddenName = propName; // Change if you need a different property name.
//
//         // 1. Determine the converter (null if not enum).
//         sb.AppendLine("            {");
//         sb.AppendLine("                global::System.Text.Json.Serialization.JsonConverter? propConverter = null;");
//         sb.AppendLine($"                if (typeof({propTypeName}).IsEnum)");
//         sb.AppendLine("                {");
//         sb.AppendLine("                    propConverter = (global::System.Text.Json.Serialization.JsonConverter?)");
//         sb.AppendLine("                        global::System.Activator.CreateInstance(");
//         sb.AppendLine("                            typeof(global::System.Text.Json.Serialization.JsonStringEnumConverter<>).MakeGenericType(");
//         sb.AppendLine($"                                typeof({propTypeName})");
//         sb.AppendLine("                            )");
//         sb.AppendLine("                        );");
//         sb.AppendLine("                }");
//         sb.AppendLine();
//
//         // 2. Instantiate propertyValues, using an object initializer so we can set Converter in one step.
//         sb.AppendLine($"                var propertyValues = new global::System.Text.Json.Serialization.Metadata.JsonPropertyInfoValues<{propTypeName}>()");
//         sb.AppendLine("                {");
//         sb.AppendLine($"                    PropertyName = \"{overriddenName}\",");
//         sb.AppendLine($"                    Getter = static obj => ((global::{ns}.{extensionClassName}.{className})obj).{propName},");
//         sb.AppendLine($"                    Setter = static (obj, val) => ((global::{ns}.{extensionClassName}.{className})obj).{propName} = val,");
//         sb.AppendLine($"                    Converter = propConverter !=null? (global::System.Text.Json.Serialization.JsonConverter<{propTypeName}>) propConverter : null");
//         sb.AppendLine("                };");
//         sb.AppendLine();
//
//         sb.AppendLine("                // Build the actual JsonPropertyInfo");
//         sb.AppendLine($"                var propertyInfo = global::System.Text.Json.Serialization.Metadata.JsonMetadataServices.CreatePropertyInfo<{propTypeName}>(");
//         sb.AppendLine("                    new global::System.Text.Json.JsonSerializerOptions(),");
//         sb.AppendLine("                    propertyValues");
//         sb.AppendLine("                );");
//         sb.AppendLine();
//         sb.AppendLine("                propertyInfos.Add(propertyInfo);");
//         sb.AppendLine("            }");
//         sb.AppendLine();
//     }
//
//     sb.AppendLine("            // Now define how to create an instance of our class and attach these properties.");
//     sb.AppendLine($"            var objectInfoValues = new global::System.Text.Json.Serialization.Metadata.JsonObjectInfoValues<global::{ns}.{extensionClassName}.{className}>");
//     sb.AppendLine("            {");
//     sb.AppendLine($"                ObjectCreator = () => new global::{ns}.{extensionClassName}.{className}(),");
//     sb.AppendLine($"                PropertyMetadataInitializer = (obj) =>{{return propertyInfos.ToArray();}}");
//     sb.AppendLine("            };");
//     sb.AppendLine();
//
//     //sb.AppendLine("            // Add the properties we discovered above");
//    // sb.AppendLine("            objectInfoValues.PropertyMetadataInitializer+= (obj) =>{return propertyInfos;};");
//     
//     // sb.AppendLine("            foreach (var propInfo in propertyInfos)");
//     // sb.AppendLine("            {");
//     // sb.AppendLine("                objectInfoValues.PropertyMetadata.Add(propInfo);");
//     // sb.AppendLine("            }");
//     sb.AppendLine();
//
//     sb.AppendLine("            // Create the JsonTypeInfo for our class.");
//     sb.AppendLine($"            var typeInfo = global::System.Text.Json.Serialization.Metadata.JsonMetadataServices.CreateObjectInfo<global::{ns}.{extensionClassName}.{className}>(");
//     sb.AppendLine("                new global::System.Text.Json.JsonSerializerOptions(),");
//     sb.AppendLine("                objectInfoValues");
//     sb.AppendLine("            );");
//     sb.AppendLine();
//     sb.AppendLine("            return typeInfo;");
//     sb.AppendLine("        }");
//     sb.AppendLine("    }");
//
//     return sb.ToString();
// }
